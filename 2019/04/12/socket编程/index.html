
<!DOCTYPE html>
<html lang class="loading">
<head><meta name="generator" content="Hexo 3.8.0">
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    <meta name="viewport" content="width=device-width, minimum-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>socket网络编程 - gqxing&#39;s blog</title>
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="google" content="notranslate">
    <meta name="keywords" content="gqxing,"> 
    <meta name="description" content="blog summary of  what I have learn,介绍​    网络上的两个程序通过一个双向的通信连接实现数据的交换，这个连接的一端称为一个socket。
过程介绍​    服务器端和客户端通信过程如下所示：

服务端​    服务端的过程主要在该,"> 
    <meta name="author" content="guo qingxing"> 
    <link rel="alternative" href="atom.xml" title="gqxing&#39;s blog" type="application/atom+xml"> 
    <link rel="icon" href="/img/favicon.png"> 
    <link rel="stylesheet" href="//cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.css">
    <link rel="stylesheet" href="/css/diaspora.css">
    <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
    <script>
         (adsbygoogle = window.adsbygoogle || []).push({
              google_ad_client: "ca-pub-8691406134231910",
              enable_page_level_ads: true
         });
    </script>
    <script async custom-element="amp-auto-ads" src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
    </script>
</head>
</html>
<body class="loading">
    <span id="config-title" style="display:none">gqxing&#39;s blog</span>
    <div id="loader"></div>
    <div id="single">
    <div id="top" style="display: block;">
    <div class="bar" style="width: 0;"></div>
    <a class="icon-home image-icon" href="javascript:;" data-url="https://gqxing.github.io"></a>
    <div title="播放/暂停" class="icon-play"></div>
    <h3 class="subtitle">socket网络编程</h3>
    <div class="social">
        <!--<div class="like-icon">-->
            <!--<a href="javascript:;" class="likeThis active"><span class="icon-like"></span><span class="count">76</span></a>-->
        <!--</div>-->
        <div>
            <div class="share">
                <a title="获取二维码" class="icon-scan" href="javascript:;"></a>
            </div>
            <div id="qr"></div>
        </div>
    </div>
    <div class="scrollbar"></div>
</div>

    <div class="section">
        <div class="article">
    <div class="main">
        <h1 class="title">socket网络编程</h1>
        <div class="stuff">
            <span>四月 12, 2019</span>
            
  <ul class="post-tags-list"><li class="post-tags-list-item"><a class="post-tags-list-link" href="/tags/网络编程/">网络编程</a></li></ul>


        </div>
        <div class="content markdown">
            <h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>​    网络上的两个程序通过一个双向的通信连接实现数据的交换，这个连接的一端称为一个socket。</p>
<h2 id="过程介绍"><a href="#过程介绍" class="headerlink" title="过程介绍"></a>过程介绍</h2><p>​    服务器端和客户端通信过程如下所示：</p>
<p><img src="http://images.cnblogs.com/cnblogs_com/helloworldcode/1414395/o_05232335-fb19fc7527e944d4845ef40831da4ec2.png" alt="socket通信过程"></p>
<h3 id="服务端"><a href="#服务端" class="headerlink" title="服务端"></a>服务端</h3><p>​    服务端的过程主要在该图的左侧部分，下面对上图的每一步进行详细的介绍。</p>
<h4 id="1-套接字对象的创建"><a href="#1-套接字对象的创建" class="headerlink" title="1. 套接字对象的创建"></a>1. 套接字对象的创建</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    * _domain 套接字使用的协议族信息</span></span><br><span class="line"><span class="comment">    * _type 套接字的传输类型</span></span><br><span class="line"><span class="comment">    * __protocol 通信协议</span></span><br><span class="line"><span class="comment">    * */</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">socket</span> <span class="params">(<span class="keyword">int</span> __domain, <span class="keyword">int</span> __type, <span class="keyword">int</span> __protocol)</span> __THROW</span>;</span><br></pre></td></tr></table></figure>
<p>socket起源于UNIX，在Unix一切皆文件哲学的思想下，socket是一种”打开—读/写—关闭”模式的实现，可以将该函数类比常用的<code>open()</code>函数，服务器和客户端各自维护一个”文件”，在建立连接打开后，可以向自己文件写入内容供对方读取或者读取对方内容，通讯结束时关闭文件。</p>
<p><strong>参数介绍</strong></p>
<p>第一个参数：关于协议族信息可选字段如下，只列出一般常见的字段。</p>
<table>
<thead>
<tr>
<th style="text-align:center">地址族</th>
<th style="text-align:center">含义</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">AF_INET</td>
<td style="text-align:center">IPv4网络协议中采用的地址族</td>
</tr>
<tr>
<td style="text-align:center">AF_INET6</td>
<td style="text-align:center">IPv6网络协议中采用的地址族</td>
</tr>
<tr>
<td style="text-align:center">AF_LOCAL</td>
<td style="text-align:center">本地通信中采用的UNIX协议的地址族（用的少）</td>
</tr>
</tbody>
</table>
<p>第二个参数：套接字类型。常用的有SOCKET_RAW，SOCK_STREAM和SOCK_DGRAM。</p>
<table>
<thead>
<tr>
<th style="text-align:center">套接字类型</th>
<th style="text-align:center">含义</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">SOCKET_RAW</td>
<td style="text-align:center">原始套接字(SOCKET_RAW)允许对较低层次的协议直接访问，比如IP、 ICMP协议。</td>
</tr>
<tr>
<td style="text-align:center">SOCK_STREAM</td>
<td style="text-align:center">SOCK_STREAM是数据流，一般为TCP/IP协议的编程。</td>
</tr>
<tr>
<td style="text-align:center">SOCK_DGRAM</td>
<td style="text-align:center">SOCK_DGRAM是数据报，一般为UDP协议的网络编程；</td>
</tr>
</tbody>
</table>
<p>第三个参数：最终采用的协议。常见的协议有IPPROTO_TCP、IPPTOTO_UDP。如果第二个参数选择了SOCK_STREAM，那么采用的协议就只能是IPPROTO_TCP；如果第二个参数选择的是SOCK_DGRAM，则采用的协议就只能是IPPTOTO_UDP。</p>
<h4 id="2-向套接字分配网络地址——bind"><a href="#2-向套接字分配网络地址——bind" class="headerlink" title="2. 向套接字分配网络地址——bind()"></a>2. 向套接字分配网络地址——bind()</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">* __fd:socket描述字，也就是socket引用</span></span><br><span class="line"><span class="comment">* myaddr:要绑定给sockfd的协议地址</span></span><br><span class="line"><span class="comment">* __len:地址的长度</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bind</span> <span class="params">(<span class="keyword">int</span> __fd, <span class="keyword">const</span> struct sockaddr* myaddr, <span class="keyword">socklen_t</span> __len)</span>  __THROW</span>;</span><br></pre></td></tr></table></figure>
<p>第一个参数：socket文件描述符<code>__fd</code>即套接字创建时返回的对象，</p>
<p>第二个参数：<code>myaddr</code>则是填充了一些网络地址信息，包含通信所需要的相关信息，其结构体具体如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr</span></span></span><br><span class="line"><span class="class">  &#123;</span></span><br><span class="line">    <span class="keyword">sa_family_t</span> sin_family;	<span class="comment">/* Common data: address family and length.  */</span></span><br><span class="line">    <span class="keyword">char</span> sa_data[<span class="number">14</span>];		<span class="comment">/* Address data.  */</span></span><br><span class="line">  &#125;;</span><br></pre></td></tr></table></figure>
<p>在具体传参的时候，会用该结构体的变体<code>sockaddr_in</code>形式去初始化相关字段，该结构体具体形式如下，结构体<code>sockaddr</code>中的<code>sa_data</code>就保存着地址信息需要的IP地址和端口号，对应着结构体<code>sockaddr_in</code>的<code>sin_port</code>和<code>sin_addr</code>字段。</p>
 <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span>&#123;</span></span><br><span class="line">    <span class="keyword">sa_family_t</span> sin_family;		<span class="comment">//前面介绍的地址族</span></span><br><span class="line">    <span class="keyword">uint16_t</span> sin_port;			<span class="comment">//16位的TCP/UDP端口号</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">in_addr</span> <span class="title">sin_addr</span>;</span>	<span class="comment">//32位的IP地址</span></span><br><span class="line">    <span class="keyword">char</span> sin_zero[<span class="number">8</span>];			<span class="comment">//不使用</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>in_addr</code>  结构定义如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Internet address.  */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">uint32_t</span> <span class="keyword">in_addr_t</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">in_addr</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="keyword">in_addr_t</span> s_addr;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>而<code>sin_zero</code> 无特殊的含义，只是为了与下面介绍的sockaddr结构体一致而插入的成员。因为在给套接字分配网络地址的时候会调用<code>bind</code>函数，其中的参数会把<code>sockaddr_in</code>转化为<code>sockaddr</code>的形式，如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">serv_addr</span>;</span></span><br><span class="line">...</span><br><span class="line">bind(serv_socket, (struct sockaddr*)&amp;serv_addr, <span class="keyword">sizeof</span>(serv_addr)；</span><br></pre></td></tr></table></figure>
<p>需要注意的是<code>s_addr</code>是一种<code>uint32_t</code>类型的数据，而且在网络传输时，统一都是以大端序的网络字节序方式传输数据，而我们通常习惯的IP地址格式是点分十进制，例如：“219.228.148.169”，这个时候就会调用以下函数进行转化，将IP地址转化为32位的整数形数据，同时进行网络字节转换：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">in_addr_t</span> inet_addr (<span class="keyword">const</span> <span class="keyword">char</span> *__cp) __THROW;</span><br><span class="line"><span class="comment">//或者</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">inet_aton</span> <span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *__cp, struct in_addr *__inp)</span> __THROW</span>;	<span class="comment">//windows无此函数</span></span><br></pre></td></tr></table></figure>
<p>如果单纯要进行网络字节序地址的转换，可以采用如下函数：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*Functions to convert between host and network byte order.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">   Please note that these functions normally take `unsigned long int' or</span></span><br><span class="line"><span class="comment">   `unsigned short int' values as arguments and also return them.  But</span></span><br><span class="line"><span class="comment">   this was a short-sighted decision since on different systems the types</span></span><br><span class="line"><span class="comment">   may have different representations but the values are always the same.  */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// h代表主机字节序</span></span><br><span class="line"><span class="comment">// n代表网络字节序</span></span><br><span class="line"><span class="comment">// s代表short(4字节)</span></span><br><span class="line"><span class="comment">// l代表long(8字节)</span></span><br><span class="line"><span class="function"><span class="keyword">extern</span> uint32_t <span class="title">ntohl</span> <span class="params">(<span class="keyword">uint32_t</span> __netlong)</span> __THROW __<span class="title">attribute__</span> <span class="params">((__const__))</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">extern</span> uint16_t <span class="title">ntohs</span> <span class="params">(<span class="keyword">uint16_t</span> __netshort)</span></span></span><br><span class="line"><span class="function">     __THROW __<span class="title">attribute__</span> <span class="params">((__const__))</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">extern</span> uint32_t <span class="title">htonl</span> <span class="params">(<span class="keyword">uint32_t</span> __hostlong)</span></span></span><br><span class="line"><span class="function">     __THROW __<span class="title">attribute__</span> <span class="params">((__const__))</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">extern</span> uint16_t <span class="title">htons</span> <span class="params">(<span class="keyword">uint16_t</span> __hostshort)</span></span></span><br></pre></td></tr></table></figure>
<h4 id="3-进入等待连接请求状态"><a href="#3-进入等待连接请求状态" class="headerlink" title="3. 进入等待连接请求状态"></a>3. 进入等待连接请求状态</h4><p>给套接字分配了所需的信息后，就可以调用<code>listen()</code>函数对来自客户端的连接请求进行监听（客户端此时要调用<code>connect()</code>函数进行连接）</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Prepare to accept connections on socket FD.</span></span><br><span class="line"><span class="comment">   N connection requests will be queued before further requests are refused.</span></span><br><span class="line"><span class="comment">   Returns 0 on success, -1 for errors.  */</span></span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">int</span> <span class="title">listen</span> <span class="params">(<span class="keyword">int</span> __fd, <span class="keyword">int</span> __n)</span> __THROW</span>;</span><br></pre></td></tr></table></figure>
<p>第一个参数：socket文件描述符<code>__fd</code>，分配所需的信息后的套接字。</p>
<p>第二个参数：连接请求的队列长度，如果为6，表示队列中最多同时有6个连接请求。</p>
<p>这个函数的fd(socket套接字对象)就相当于一个门卫，对连接请求做处理，决定是否把连接请求放入到server端维护的一个队列中去。</p>
<h4 id="4-受理客户端的连接请求"><a href="#4-受理客户端的连接请求" class="headerlink" title="4. 受理客户端的连接请求"></a>4. 受理客户端的连接请求</h4><p><code>listen()</code>中的sock(__fd : socket对象)发挥了服务器端接受请求的门卫作用，此时为了按序受理请求，给客户端做相应的回馈，连接到发起请求的客户端，此时就需要再次创建另一个套接字，该套接字可以用以下函数创建：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Await a connection on socket FD.</span></span><br><span class="line"><span class="comment">   When a connection arrives, open a new socket to communicate with it,</span></span><br><span class="line"><span class="comment">   set *ADDR (which is *ADDR_LEN bytes long) to the address of the connecting</span></span><br><span class="line"><span class="comment">   peer and *ADDR_LEN to the address's actual length, and return the</span></span><br><span class="line"><span class="comment">   new socket's descriptor, or -1 for errors.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">   This function is a cancellation point and therefore not marked with</span></span><br><span class="line"><span class="comment">   __THROW.  */</span></span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">int</span> <span class="title">accept</span> <span class="params">(<span class="keyword">int</span> __fd, struct sockaddr *addr, <span class="keyword">socklen_t</span> *addr_len)</span></span>;</span><br></pre></td></tr></table></figure>
<p>函数成功执行时返回socket文件描述符，失败时返回-1。</p>
<p>第一个参数：socket文件描述符<code>__fd</code>，要注意的是这个套接字文件描述符与前面几步的套接字文件描述符不同。</p>
<p>第二个参数：保存发起连接的客户端的地址信息。</p>
<p>第三个参数： 保存该结构体的长度。</p>
<h4 id="5-send-write发送信息"><a href="#5-send-write发送信息" class="headerlink" title="5. send/write发送信息"></a>5. send/write发送信息</h4><p>linux下的发送函数为：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Write N bytes of BUF to FD.  Return the number written, or -1.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">   This function is a cancellation point and therefore not marked with</span></span><br><span class="line"><span class="comment">   __THROW.  */</span></span><br><span class="line"> <span class="keyword">ssize_t</span> write (<span class="keyword">int</span> __fd, <span class="keyword">const</span> <span class="keyword">void</span> *__buf, <span class="keyword">size_t</span> __n) ;</span><br></pre></td></tr></table></figure>
<p>而在windows下的发送函数为：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ssize_t</span> send (<span class="keyword">int</span> sockfd, <span class="keyword">const</span> <span class="keyword">void</span> *buf, <span class="keyword">size_t</span> nbytes, <span class="keyword">int</span> flag) ;</span><br></pre></td></tr></table></figure>
<p>第四个参数是传输数据时可指定的信息，一般设置为0。</p>
<h4 id="6-recv-read接受信息"><a href="#6-recv-read接受信息" class="headerlink" title="6. recv/read接受信息"></a>6. recv/read接受信息</h4><p>linux下的接收函数为</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Read NBYTES into BUF from FD.  Return the</span></span><br><span class="line"><span class="comment">   number read, -1 for errors or 0 for EOF.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">   This function is a cancellation point and therefore not marked with</span></span><br><span class="line"><span class="comment">   __THROW.  */</span></span><br><span class="line"><span class="keyword">ssize_t</span> read (<span class="keyword">int</span> __fd, <span class="keyword">void</span> *__buf, <span class="keyword">size_t</span> __nbytes);</span><br></pre></td></tr></table></figure>
<p>而在windows下的接收函数为</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ssize_t</span> recv(<span class="keyword">int</span> sockfd, <span class="keyword">void</span> *buf, <span class="keyword">size_t</span> nbytes, <span class="keyword">int</span> flag) ;</span><br></pre></td></tr></table></figure>
<h4 id="7-关闭连接"><a href="#7-关闭连接" class="headerlink" title="7 .关闭连接"></a>7 .关闭连接</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/* Close the file descriptor FD.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">   This function is a cancellation point and therefore not marked with</span></span><br><span class="line"><span class="comment">   __THROW.  */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">close</span> <span class="params">(<span class="keyword">int</span> __fd)</span></span>;</span><br></pre></td></tr></table></figure>
<p>退出连接，此时要注意的是：<strong>调用<code>close()</code>函数即表示向对方发送了<code>EOF</code>结束标志信息</strong>。</p>
<h3 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h3><p>​    服务端的socket套接字在绑定自身的IP即 及端口号后这些信息后，就开始监听端口等待客户端的连接请求，此时客户端在创建套接字后就可以按照如下步骤与server端通信，创建套接字的过程不再重复了。</p>
<h4 id="1-请求连接"><a href="#1-请求连接" class="headerlink" title="1.  请求连接"></a>1.  请求连接</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Open a connection on socket FD to peer at ADDR (which LEN bytes long).</span></span><br><span class="line"><span class="comment">   For connectionless socket types, just set the default address to send to</span></span><br><span class="line"><span class="comment">   and the only address from which to accept transmissions.</span></span><br><span class="line"><span class="comment">   Return 0 on success, -1 for errors.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">   This function is a cancellation point and therefore not marked with</span></span><br><span class="line"><span class="comment">   __THROW.  */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">connect</span> <span class="params">(<span class="keyword">int</span> socket, struct sockaddr* servaddr, <span class="keyword">socklen_t</span> addrlen)</span></span>;</span><br></pre></td></tr></table></figure>
<p>几个参数的意义和前面的accept函数意义一样。要注意的是服务器端收到连接请求的时候并不是马上调用accept()函数，而是把它放入到请求信息的等待队列中。</p>
<h2 id="套接字的多种可选项"><a href="#套接字的多种可选项" class="headerlink" title="套接字的多种可选项"></a>套接字的多种可选项</h2><p>可以通过如下函数对套接字可选项的参数进行获取以及设置。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Put the current value for socket FD's option OPTNAME at protocol level LEVEL</span></span><br><span class="line"><span class="comment">   into OPTVAL (which is *OPTLEN bytes long), and set *OPTLEN to the value's</span></span><br><span class="line"><span class="comment">   actual length.  Returns 0 on success, -1 for errors.  */</span></span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">int</span> <span class="title">getsockopt</span> <span class="params">(<span class="keyword">int</span> sock, <span class="keyword">int</span> __level, <span class="keyword">int</span> __optname,</span></span></span><br><span class="line"><span class="function"><span class="params">		       <span class="keyword">void</span> *__optval, <span class="keyword">socklen_t</span> *optlen)</span> __THROW</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Set socket FD's option OPTNAME at protocol level LEVEL</span></span><br><span class="line"><span class="comment">   to *OPTVAL (which is OPTLEN bytes long).</span></span><br><span class="line"><span class="comment">   Returns 0 on success, -1 for errors.  */</span></span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">int</span> <span class="title">setsockopt</span> <span class="params">(<span class="keyword">int</span> sock, <span class="keyword">int</span> __level, <span class="keyword">int</span> __optname,</span></span></span><br><span class="line"><span class="function"><span class="params">		       <span class="keyword">const</span> <span class="keyword">void</span> *__optval, <span class="keyword">socklen_t</span> __optlen)</span> __THROW</span>;</span><br></pre></td></tr></table></figure>
<p>参数说明：</p>
<p><strong>scok</strong>： 套接字的文件描述符</p>
<p><strong>__level </strong>：可选项的协议层，如下：</p>
<table>
<thead>
<tr>
<th style="text-align:center"><strong>协议层</strong></th>
<th style="text-align:center"><strong>功能</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">SOL_SOCKET</td>
<td style="text-align:center">套接字相关通用可选项的设置</td>
</tr>
<tr>
<td style="text-align:center">IPPROTO_IP</td>
<td style="text-align:center">在IP层设置套接字的相关属性</td>
</tr>
<tr>
<td style="text-align:center">IPPROTO_TCP</td>
<td style="text-align:center">在TCP层设置套接字相关属性</td>
</tr>
</tbody>
</table>
<p><strong>__optname</strong> ：要查看的可选项名，几个主要的选项如下</p>
<table>
<thead>
<tr>
<th style="text-align:center"><strong>选项名</strong></th>
<th style="text-align:center"><strong>说明</strong></th>
<th style="text-align:center"><strong>数据类型</strong></th>
<th>所属协议层</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">SO_RCVBUF</td>
<td style="text-align:center">接收缓冲区大小</td>
<td style="text-align:center">int</td>
<td>SOL_SOCKET</td>
</tr>
<tr>
<td style="text-align:center">SO_SNDBUF</td>
<td style="text-align:center">发送缓冲区大小</td>
<td style="text-align:center">int</td>
<td>SOL_SOCKET</td>
</tr>
<tr>
<td style="text-align:center">SO_RCVLOWAT</td>
<td style="text-align:center">接收缓冲区下限</td>
<td style="text-align:center">int</td>
<td>SOL_SOCKET</td>
</tr>
<tr>
<td style="text-align:center">SO_SNDLOWAT</td>
<td style="text-align:center">发送缓冲区下限</td>
<td style="text-align:center">int</td>
<td>SOL_SOCKET</td>
</tr>
<tr>
<td style="text-align:center">SO_TYPE</td>
<td style="text-align:center">获得套接字类型(这个只能获取，不能设置)</td>
<td style="text-align:center">int</td>
<td>SOL_SOCKET</td>
</tr>
<tr>
<td style="text-align:center">SO_REUSEADDR</td>
<td style="text-align:center">是否启用地址再分配，主要原理是操作关闭套接字的Time-wait时间等待的开启和关闭</td>
<td style="text-align:center">int</td>
<td>SOL_SOCKET</td>
</tr>
<tr>
<td style="text-align:center">IP_HDRINCL</td>
<td style="text-align:center">在数据包中包含IP首部</td>
<td style="text-align:center">int</td>
<td>IPPROTO_IP</td>
</tr>
<tr>
<td style="text-align:center">IP_MULTICAST_TTL</td>
<td style="text-align:center">生存时间(Time To Live)，组播传送距离</td>
<td style="text-align:center">int</td>
<td>IPPROTO_IP</td>
</tr>
<tr>
<td style="text-align:center">IP_ADD_MEMBERSHIP</td>
<td style="text-align:center">加入组播</td>
<td style="text-align:center">int</td>
<td>IPPROTO_IP</td>
</tr>
<tr>
<td style="text-align:center">IP_OPTINOS</td>
<td style="text-align:center">IP首部选项</td>
<td style="text-align:center">int</td>
<td>IPPROTO_IP</td>
</tr>
<tr>
<td style="text-align:center">TCP_NODELAY</td>
<td style="text-align:center">不使用Nagle算法</td>
<td style="text-align:center">int</td>
<td>IPPROTO_TCP</td>
</tr>
<tr>
<td style="text-align:center">TCP_KEEPALIVE</td>
<td style="text-align:center">TCP保活机制开启下，设置保活包空闲发送时间间隔</td>
<td style="text-align:center">int</td>
<td>IPPROTO_TCP</td>
</tr>
<tr>
<td style="text-align:center">TCP_KEEPINTVL</td>
<td style="text-align:center">TCP保活机制开启下，设置保活包无响应情况下重发时间间隔</td>
<td style="text-align:center">int</td>
<td>IPPROTO_TCP</td>
</tr>
<tr>
<td style="text-align:center">TCP_KEEPCNT</td>
<td style="text-align:center">TCP保活机制开启下，设置保活包无响应情况下重复发送次数</td>
<td style="text-align:center">int</td>
<td>IPPROTO_TCP</td>
</tr>
<tr>
<td style="text-align:center">TCP_MAXSEG</td>
<td style="text-align:center">TCP最大数据段的大小</td>
<td style="text-align:center">int</td>
<td>IPPROTO_TCP</td>
</tr>
</tbody>
</table>
<p><strong>__optval</strong>  ：保存查看(get)/更改(set)的结果</p>
<p><strong>optlen</strong> ： 传递第四个参数的字节大小</p>
<p>这里只对几个可选项参数进行说明：</p>
<h4 id="1-设置可选项的IO缓冲区大小"><a href="#1-设置可选项的IO缓冲区大小" class="headerlink" title="1.设置可选项的IO缓冲区大小"></a>1.设置可选项的IO缓冲区大小</h4><p>参考案例如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> status, snd_buf;</span><br><span class="line"><span class="keyword">socklen_t</span> len = <span class="keyword">sizeof</span>(snd_buf);</span><br><span class="line">status = getsockopt(serv_socket, SOL_SOCKET, SO_SNDBUF, (<span class="keyword">void</span>*)&amp;snd_buf, &amp;len);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"发送缓冲区大小: "</span> &lt;&lt; snd_buf &lt;&lt;<span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure>
<p>虽然可以获得的接收/发送缓冲区的大小，但是通过设置接收/发送缓冲区大小时，得到的结果会与我们期望的不一样，因为对缓冲区大小的设置是一件很谨慎的事，其自身会根据设置的值进行一定的优化。</p>
<h4 id="2-是否启用地址再分配与Time-wait时间等待"><a href="#2-是否启用地址再分配与Time-wait时间等待" class="headerlink" title="2. 是否启用地址再分配与Time-wait时间等待"></a>2. 是否启用地址再分配与Time-wait时间等待</h4><p>关于地址再分配问题会发生在这种情况下，首先看两种情况，假设客户端和服务器正在通讯（测试代码<a href="https://github.com/GQXING/Socket-Program/tree/master/first_example" target="_blank" rel="noopener">下载地址</a>）。</p>
<p>① 在客户端的终端按<code>Crtl + c</code>或者其他方式断开与服务器的连接，此时客户端发送FIN消息，经过四次握手断开连接，操作系统关闭套接字，相当于<code>close()</code>的过程。然后在次启动客户端，顺利启动。</p>
<p>② 在服务端的终端按<code>Crtl + c</code>或者其他方式断开与客户端的连接，像①中一样，再次启动服务端，此时出现<code>bind() error</code>错误。</p>
<p>服务器端出现这种情况的原因是调用套接字分配网络地址函数<code>bind()</code>的时候之前使用建立连接的同一端口号还没有来得及停用（大约要过两三分钟才处于可用状态），而客户端申请连接的端口是任意指定，程序运行时会动态分配端口号。</p>
<p>服务器端端口没有被释放到被释放的时间状态称为Time-wait状态，这个状态的出现可以借助TCP断开连接的四次握手协议来分析，如下图：</p>
<p><img src="/2019/04/12/socket编程/closed.jpg" alt="四次握手协议"></p>
<p>当client端发送<code>ACK=1 ack=k+1</code>这个消息给服务端就立即消除套接字，若此时该消息中途传输被遗失，则这个时候server端就永远无法收到client的<code>ACK</code>消息了。</p>
<h4 id="3-TCP-NODELAY"><a href="#3-TCP-NODELAY" class="headerlink" title="3. TCP_NODELAY"></a>3. TCP_NODELAY</h4><p>TCP套接字默认是使用Nagle算法的，该算法的特征是<strong>只有收到前一条数据的ACK消息后，才会发送下一条数据。</strong></p>
<p>从网上找到一张图说明使用和禁用Nagle算法的区别（<a href="http://www.it610.com/article/5254468.htm" target="_blank" rel="noopener">图片来源</a>），如下：</p>
<p><img src="/2019/04/12/socket编程/timg.jpeg" alt="Nagle"></p>
<p>设置代码如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netinet/tcp.h&gt; //注意要引入这个头文件</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> opt_val = <span class="number">1</span>;</span><br><span class="line">setsockopt(serv_socket, IPPROTO_TCP, TCP_NODELAY, (<span class="keyword">void</span>*)&amp;opt_val, <span class="keyword">sizeof</span>(opt_val));</span><br></pre></td></tr></table></figure>
<h2 id="程序案例"><a href="#程序案例" class="headerlink" title="程序案例"></a>程序案例</h2><p>案例的过程，在网上看到了关于read和write的发送与接受过程的图，便于理解：</p>
<p><img src="http://images.cnblogs.com/cnblogs_com/helloworldcode/1414395/o_TCP-socket.jpg" alt></p>
<h4 id="服务端程序"><a href="#服务端程序" class="headerlink" title="服务端程序"></a>服务端程序</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">errorhandling</span><span class="params">(<span class="keyword">char</span> *message)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> serv_socket;</span><br><span class="line">    <span class="keyword">int</span> clnt_socket;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">serv_addr</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">clnt_addr</span>;</span></span><br><span class="line">    <span class="keyword">socklen_t</span> clnt_addr_size;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span> message[] = <span class="string">"Hello world!"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(argc != <span class="number">2</span>)&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"Usage : "</span> &lt;&lt; argv[<span class="number">0</span>] &lt;&lt; <span class="string">" &lt;port&gt; "</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    serv_socket = socket(PF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(serv_socket == <span class="number">-1</span>)&#123;</span><br><span class="line">        errorhandling(<span class="string">"socket() error!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(&amp;serv_addr, <span class="number">0</span>, <span class="keyword">sizeof</span>(serv_addr));</span><br><span class="line">    serv_addr.sin_family = AF_INET;</span><br><span class="line">    serv_addr.sin_addr.s_addr = htonl(INADDR_ANY); <span class="comment">//自动获取计算机的IP地址</span></span><br><span class="line">    serv_addr.sin_port = htons(atoi(argv[<span class="number">1</span>]));  <span class="comment">//atoi (表示ascii to integer)是把字符串转换成整型数的一个函数</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(bind(serv_socket, (struct sockaddr*)&amp;serv_addr, <span class="keyword">sizeof</span>(serv_addr)) == <span class="number">-1</span>)&#123;</span><br><span class="line">        errorhandling(<span class="string">"bind() error"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(listen(serv_socket, <span class="number">5</span>) == <span class="number">-1</span>)&#123;</span><br><span class="line">        errorhandling(<span class="string">"listen() error"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    clnt_addr_size = <span class="keyword">sizeof</span>(clnt_addr);</span><br><span class="line">    clnt_socket = accept(serv_socket, (struct sockaddr*)&amp;clnt_addr, &amp;clnt_addr_size);</span><br><span class="line">    <span class="keyword">if</span>(clnt_socket == <span class="number">-1</span>)&#123;</span><br><span class="line">        errorhandling(<span class="string">"accept error"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    write(clnt_socket, message, <span class="keyword">sizeof</span>(message));</span><br><span class="line"></span><br><span class="line">    close(clnt_socket);</span><br><span class="line">    close(serv_socket);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">errorhandling</span><span class="params">(<span class="keyword">char</span> *message)</span></span>&#123;</span><br><span class="line">    <span class="built_in">fputs</span>(message, <span class="built_in">stderr</span>);</span><br><span class="line">    fputc(<span class="string">'\n'</span>, <span class="built_in">stderr</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="客户端程序"><a href="#客户端程序" class="headerlink" title="客户端程序"></a>客户端程序</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">errorhandling</span><span class="params">(<span class="keyword">char</span> *message)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sock;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">serv_addr</span>;</span></span><br><span class="line">    <span class="keyword">char</span> message[<span class="number">20</span>];</span><br><span class="line">    <span class="keyword">int</span> str_len = <span class="number">0</span> ,idx = <span class="number">0</span>, read_len = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(argc != <span class="number">3</span>)&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"Usage : "</span> &lt;&lt; argv[<span class="number">0</span>] &lt;&lt; <span class="string">"&lt;IP&gt; &lt;port&gt; "</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    sock = socket(PF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(sock == <span class="number">-1</span>)&#123;</span><br><span class="line">        errorhandling(<span class="string">"socket() error;"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(&amp;serv_addr, <span class="number">0</span>, <span class="keyword">sizeof</span>(serv_addr));</span><br><span class="line">    serv_addr.sin_family = AF_INET;</span><br><span class="line">    serv_addr.sin_addr.s_addr = inet_addr(argv[<span class="number">1</span>]);</span><br><span class="line">    serv_addr.sin_port = htons(atoi(argv[<span class="number">2</span>]));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(connect(sock, (struct sockaddr*)&amp;serv_addr, <span class="keyword">sizeof</span>(serv_addr)) == <span class="number">-1</span>)&#123;</span><br><span class="line">        errorhandling(<span class="string">"connect error!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(read_len =read(sock, &amp;message[idx++], <span class="number">1</span>))&#123;</span><br><span class="line">        <span class="keyword">if</span>(read_len == <span class="number">-1</span>)&#123;</span><br><span class="line">            errorhandling(<span class="string">"read error"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        str_len += read_len;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"message from server: "</span> &lt;&lt; message &lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"read function call "</span> &lt;&lt; str_len &lt;&lt; <span class="string">"times"</span> &lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    close(sock);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">errorhandling</span><span class="params">(<span class="keyword">char</span> *message)</span></span>&#123;</span><br><span class="line">    <span class="built_in">fputs</span>(message, <span class="built_in">stderr</span>);</span><br><span class="line">    fputc(<span class="string">'\n'</span>, <span class="built_in">stderr</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="编译运行"><a href="#编译运行" class="headerlink" title="编译运行"></a>编译运行</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span>服务端</span><br><span class="line">gqx@gqx-Lenovo-Product:~/workplace/SocketServer$ g++ -o server main.cpp</span><br><span class="line">gqx@gqx-Lenovo-Product:~/workplace/SocketServer$ ./server 9999</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span>客户端</span><br><span class="line">gqx@gqx-Lenovo-Product:~/workplace/SocketClient$ g++ -o client main.cpp</span><br><span class="line">gqx@gqx-Lenovo-Product:~/workplace/SocketClient$ ./client 127.0.0.1 9999</span><br></pre></td></tr></table></figure>
<p>注意以上代码都是在ubuntu下运行的，在windows的代码与此有所不同。比如要引入一个<code>&lt;winsock2.h&gt;</code>的头文件，调用<code>WSAStartup(...)</code>函数进行Winsock的初始化，而且它们的接受与发送函数也有所不同。</p>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p><a href="https://www.cnblogs.com/dolphinX/p/3460545.html" target="_blank" rel="noopener">简单理解Socket</a></p>
<p><a href="https://baike.baidu.com/item/%E5%A5%97%E6%8E%A5%E5%AD%97" target="_blank" rel="noopener">套接字</a></p>
<p>《TCP/IP网络编程》尹圣雨</p>

            <!--[if lt IE 9]><script>document.createElement('audio');</script><![endif]-->
            <audio id="audio" loop="1" preload="auto" controls="controls" data-autoplay="false">
                <source type="audio/mpeg" src="http://domain.com/awesome.mp3">
            </audio>
            
        </div>
        
    <div id="gitalk-container" class="comment link" data-ae="true" data-ci="f23c4358968f2d02bb54" data-cs="7cc5b02f1f7793e05db389bc523127458e6f5857" data-r="gqxing.github.io" data-o="GQXing" data-a="GQXing" data-d="true">查看评论</div>


    </div>
    
        <div class="side">
            <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#介绍"><span class="toc-number">1.</span> <span class="toc-text">介绍</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#过程介绍"><span class="toc-number">2.</span> <span class="toc-text">过程介绍</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#服务端"><span class="toc-number">2.1.</span> <span class="toc-text">服务端</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-套接字对象的创建"><span class="toc-number">2.1.1.</span> <span class="toc-text">1. 套接字对象的创建</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-向套接字分配网络地址——bind"><span class="toc-number">2.1.2.</span> <span class="toc-text">2. 向套接字分配网络地址——bind()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-进入等待连接请求状态"><span class="toc-number">2.1.3.</span> <span class="toc-text">3. 进入等待连接请求状态</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-受理客户端的连接请求"><span class="toc-number">2.1.4.</span> <span class="toc-text">4. 受理客户端的连接请求</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-send-write发送信息"><span class="toc-number">2.1.5.</span> <span class="toc-text">5. send/write发送信息</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-recv-read接受信息"><span class="toc-number">2.1.6.</span> <span class="toc-text">6. recv/read接受信息</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-关闭连接"><span class="toc-number">2.1.7.</span> <span class="toc-text">7 .关闭连接</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#客户端"><span class="toc-number">2.2.</span> <span class="toc-text">客户端</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-请求连接"><span class="toc-number">2.2.1.</span> <span class="toc-text">1.  请求连接</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#套接字的多种可选项"><span class="toc-number">3.</span> <span class="toc-text">套接字的多种可选项</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-设置可选项的IO缓冲区大小"><span class="toc-number">3.0.1.</span> <span class="toc-text">1.设置可选项的IO缓冲区大小</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-是否启用地址再分配与Time-wait时间等待"><span class="toc-number">3.0.2.</span> <span class="toc-text">2. 是否启用地址再分配与Time-wait时间等待</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-TCP-NODELAY"><span class="toc-number">3.0.3.</span> <span class="toc-text">3. TCP_NODELAY</span></a></li></ol></li></ol><li class="toc-item toc-level-2"><a class="toc-link" href="#程序案例"><span class="toc-number">4.</span> <span class="toc-text">程序案例</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#服务端程序"><span class="toc-number">4.0.1.</span> <span class="toc-text">服务端程序</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#客户端程序"><span class="toc-number">4.0.2.</span> <span class="toc-text">客户端程序</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#编译运行"><span class="toc-number">4.0.3.</span> <span class="toc-text">编译运行</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#参考文献"><span class="toc-number">5.</span> <span class="toc-text">参考文献</span></a></li>
        </div>
    
</div>


    </div>
</div>
</body>
<script src="//cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js"></script>
<script src="//lib.baomitu.com/jquery/1.8.3/jquery.min.js"></script>
<script src="/js/plugin.js"></script>
<script src="/js/diaspora.js"></script>
<link rel="stylesheet" href="/photoswipe/photoswipe.css">
<link rel="stylesheet" href="/photoswipe/default-skin/default-skin.css">
<script src="/photoswipe/photoswipe.min.js"></script>
<script src="/photoswipe/photoswipe-ui-default.min.js"></script>

<!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">
    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>
    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">
        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>
        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">
            <div class="pswp__top-bar">
                <!--  Controls are self-explanatory. Order can be changed. -->
                <div class="pswp__counter"></div>
                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>
                <button class="pswp__button pswp__button--share" title="Share"></button>
                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>
                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>
                <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                      <div class="pswp__preloader__cut">
                        <div class="pswp__preloader__donut"></div>
                      </div>
                    </div>
                </div>
            </div>
            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div> 
            </div>
            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>
            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>
            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>
        </div>
    </div>
</div>



<!-- Google Analytics -->
<script type="text/javascript">
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

  ga('create', '1', 'auto');
  ga('send', 'pageview');
</script>
<!-- End Google Analytics -->


</html>
